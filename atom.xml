<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Camel</title>
  <subtitle>qmk</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qmkcamel.github.io/"/>
  <updated>2017-03-07T09:58:49.000Z</updated>
  <id>https://qmkcamel.github.io/</id>
  
  <author>
    <name>qmkCamel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Infer 使用笔记</title>
    <link href="https://qmkcamel.github.io/2017/03/07/Infer%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://qmkcamel.github.io/2017/03/07/Infer使用笔记/</id>
    <published>2017-03-06T16:00:00.000Z</published>
    <updated>2017-03-07T09:58:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>Facebook 的 Infer 是一个由 OCaml 编写的静态分析工具。<br>这种查错工具并不是简单纠正一下语法，而是一种代码静态分析工具。它可以在不运行代码（一般开发者的调试方式都是编译、运行，查看结果，然后人工分析代码）的方式下，通过词法分析、语法分析、控制流、数据流分析等技术对程序代码进行扫描，来验证代码是否存在问题或满足技术指标。</p>
<p>下文示例主要以一个iOS开发者的角度来阐述。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Infer根植于两大基本理论之上，其一是<a href="https://en.wikipedia.org/wiki/Hoare_logic" target="_blank" rel="external">霍尔逻辑</a>，一种用于推理计算机程序正确性的形式系统，另一个是<a href="https://en.wikipedia.org/wiki/Abstract_interpretation" target="_blank" rel="external">抽象解释</a>，该理论用于测度程序语义的逼近结果，此外还涉及其它一些研究成果，例如Separation Logic和Bi-abduction。   </p>
<h3 id="Infer工作流"><a href="#Infer工作流" class="headerlink" title="Infer工作流"></a>Infer工作流</h3><ol>
<li><p>捕获阶段<br> 把代码转译为Infer自己的中间语言来做静态分析。转译依赖于编译。转译之后的中间文件存储在infer-out 文件夹中。</p>
</li>
<li><p>分析阶段<br> 中间文件被分析，如果出现了错误，会停住，不会继续执行，所以会比较坑。所以一般的流程是这样的</p>
<ul>
<li>Infer 对你的项目代码做静态分析</li>
<li>分析遇到 error 并报给你</li>
<li>修复该问题代码</li>
<li><p>且再次运行 Infer 对你的项目代码做静态分析（回跳第一步）</p>
<p>当 Infer 分析代码后，会将发现的问题记录并保存到文件 infer-out/bugs.txt 中。</p>
</li>
</ul>
</li>
</ol>
<p>在 infer-out 文件夹下，Infer 还将生成一个文件 report.csv，其中包含所有 Infer 在静态分析过程中发现的错误，警告和相关信息，当然他们都是 csv 格式的。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul>
<li>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install infer</div></pre></td></tr></table></figure>
<ul>
<li>使用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">infer -- xcodebuild -target HelloWorldApp -configuration Debug </div><div class="line">-sdk iphonesimulator</div><div class="line"></div><div class="line">// 值得注意的是Infer区分增量和非增量分析，默认是增量分析，非增量分析如下</div><div class="line">infer --reactive -- xcodebuild -target HelloWorldApp -configuration Debug </div><div class="line">-sdk iphonesimulator</div><div class="line">// 或者clean之后再做分析</div><div class="line">xcodebuild -target HelloWorldApp -configuration Debug -sdk iphonesimulator clean</div><div class="line"></div><div class="line">// pod项目 其中 N.xcworkspace 是你的 workspace 名称, NSchema 是你需要检查的 Schema 名称.git </div><div class="line">infer -- xcodebuild -workspace N.xcworkspace -scheme NSchema</div></pre></td></tr></table></figure>
<ul>
<li>可以指定分析哪些文件，即whitelist和blacklist</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//项目根目录下创建一个‘.inferconfig’的文件，格式如下</div><div class="line">&#123;</div><div class="line">    <span class="string">"infer-whitelist-path-regex"</span>:[</div><div class="line">    ],</div><div class="line">    <span class="string">"infer-blacklist-path-regex"</span>:[</div><div class="line">     <span class="string">"Pods/AFNetworking"</span>,</div><div class="line">     <span class="string">"Pods/SDWebImage"</span></div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Jenkins集成"><a href="#Jenkins集成" class="headerlink" title="Jenkins集成"></a>Jenkins集成</h3><p>自动化是一个很好的东西，可以机器干的开发工程师一般不会自己去干，所以很容易就会想到把这个检查的流程自动化起来。由于我们的项目目前使用的是Jenkins，所以就想把他集成到可持续构建之中。在集成的过程中也遇到了一些问题。</p>
<h4 id="问题1-Infer-command-not-found"><a href="#问题1-Infer-command-not-found" class="headerlink" title="问题1 Infer command not found"></a>问题1 Infer command not found</h4><p>运行环境是一个Mac OS的slave节点。<br>当我在terminal中运行Infer的命令时候是正常的。但是当我Jenkins的构建过程中通过shell执行，却遇到了“Infer command not found”的错误。感觉像是PATH的问题，所以在命令行中加入了<code>export PATH=******</code>顺利解决。至于我们的PATH值怎么得来呢，直接粗暴一点的解决，在terminal中直接<code>echo $PATH</code>就能得到了。</p>
<h4 id="问题2-“ERROR-“etree”-Python-package-not-found-ERROR-You-need-to-install-it-to-use-Infer-with-–pmd-xml”"><a href="#问题2-“ERROR-“etree”-Python-package-not-found-ERROR-You-need-to-install-it-to-use-Infer-with-–pmd-xml”" class="headerlink" title="问题2 “ERROR: “etree” Python package not found.ERROR: You need to install it to use Infer with –pmd-xml”"></a>问题2 “ERROR: “etree” Python package not found.ERROR: You need to install it to use Infer with –pmd-xml”</h4><p>由于项目中已经集成了OCLint，结果用PMD plug-in来展示。所以想着直接用这个会稍微好一点。而正好Infer也是支持的（虽然默认是三种格式的报告，csv，json，plain txt）。但是在用的时候遇到了“‘etree’ Python package not found”的问题。由于对Python不是很熟悉，想当然的以为是Python版本过低造成的。在直接用<code>brew install python</code>安装了2.7.13版本（Mac OS自带的是2.7.10）之后还是依然报错。那么现在问题就比较明朗了，直接用<code>pip instlal lxml</code>安装lxml这个包之后顺利解决。</p>
<p>最后我们实际使用的shell如下 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> PATH=/Users/builder/bin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/bin:/usr/bin:/bin:/usr/sbin:/sbin</div><div class="line">PROJECT_PATH=<span class="variable">$&#123;WORKSPACE&#125;</span>;</div><div class="line"><span class="built_in">cd</span> <span class="variable">$PROJECT_PATH</span>;</div><div class="line">infer --reactive --pmd-xml -- xcodebuild -workspace HelloWorld.xcworkspace -scheme HelloWorld</div></pre></td></tr></table></figure>
<h3 id="Infer-bug-类型"><a href="#Infer-bug-类型" class="headerlink" title="Infer bug 类型"></a>Infer bug 类型</h3><h4 id="C-and-Objective-C"><a href="#C-and-Objective-C" class="headerlink" title="C and Objective-C"></a>C and Objective-C</h4><ul>
<li>Null dereference //空指针</li>
<li>Memory leak //内存泄露</li>
<li>Premature nil termination argument //过早nil导致的问题</li>
<li>Resource leak //资源代表文件，socket，链接等等，使用后需要关闭</li>
</ul>
<h4 id="only-in-Objective-C"><a href="#only-in-Objective-C" class="headerlink" title="only in Objective-C"></a>only in Objective-C</h4><ul>
<li>Ivar not null checked //和 null dereference很像</li>
<li>Paramter not null checked //和 null derefence很像</li>
<li>Retail cycle</li>
</ul>
<h3 id="linters-bug-types"><a href="#linters-bug-types" class="headerlink" title="linters bug types"></a>linters bug types</h3><blockquote>
<p>Linters check syntax of program, it could be about a property , or about code inside one method , or that a class or method have certain properties .<br> The Linter are run default when you run Infer.<br> Soon will have DSL(Domain Specific Lauguage) to extend.</p>
</blockquote>
<ul>
<li>assign pointer warning </li>
<li>bad pointer comparsion</li>
<li>C++ reference captured in Objective-C block</li>
<li>direction access atomic property </li>
<li>global variable initialized with function or method call </li>
<li>registered observer being deallocated</li>
<li>strong delegate warning </li>
<li><p>unavailable api in support SDK </p>
<ul>
<li><p>need pass to Infer the option –iphoneos-target-sdk-version version. </p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">infer</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">iphoneos</span><span class="literal">-</span><span class="comment">target</span><span class="literal">-</span><span class="comment">sdk</span><span class="literal">-</span><span class="comment">version</span> <span class="comment">8</span><span class="string">.</span><span class="comment">0</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">reactive</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">xcodebuild</span> <span class="literal">-</span><span class="comment">target</span> <span class="comment">HelloWorldApp</span> <span class="literal">-</span><span class="comment">sdk</span> <span class="comment">iphonesimulator</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>支持多语言（Java,Objective-C,C）和多平台(Android,iOS,Make)</li>
<li>作者称不久就会可扩展</li>
</ul>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ul>
<li>目前不支持Swift </li>
<li>nonsupport bug types (前三只有部分，没有覆盖全)<ul>
<li>array bounds errors</li>
<li>cast exception (转换异常)</li>
<li>leaking of tainted data (脏数据泄露) </li>
<li>concurrency race conditions (竞态条件)</li>
</ul>
</li>
<li>语言特性的欠缺<ul>
<li>Concurrency, including Java’s Concurrency Utilities and iOS’s Grand Central Dispatch</li>
<li>Dynamic dispatch</li>
<li>Reflection</li>
<li>Android lifecycles</li>
<li>Arithmetic</li>
<li>and more   </li>
</ul>
</li>
</ul>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><ul>
<li>compare to Clang Static Analyzer<ul>
<li>Infer does some things different, in particular reasoning that spans across multiple files</li>
<li>CSA checks for more kinds of issues and is also more mature than Infer when it comes to iOS </li>
</ul>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://en.wikipedia.org/wiki/Hoare_logic" target="_blank" rel="external">Hoare logic</a><br><a href="https://en.wikipedia.org/wiki/Abstract_interpretation" target="_blank" rel="external">Abstract interpretation</a><br><a href="http://fbinfer.com/docs/separation-logic-and-bi-abduction.html" target="_blank" rel="external">Separation logic and bi-abduction</a><br><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html" target="_blank" rel="external">Xcodebuild</a><br><a href="https://github.com/facebook/infer/issues/312" target="_blank" rel="external">blacklist</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Facebook 的 Infer 是一个由 OCaml 编写的静态分析工具。&lt;br&gt;这种查错工具并不是简单纠正一下语法，而是一种代码静态分析工具。它可以在不运行代码（一般开发者的调试方式都是编译、运行，查看结果，然后人工分析代码）的方式下，通过词法分析、语法分析、控制流、数
    
    </summary>
    
    
      <category term="iOS" scheme="https://qmkcamel.github.io/tags/iOS/"/>
    
      <category term="工具" scheme="https://qmkcamel.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的深复制和浅复制解读</title>
    <link href="https://qmkcamel.github.io/2016/09/10/iOS%E4%B8%AD%E7%9A%84%E6%B7%B1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B5%85%E5%A4%8D%E5%88%B6%E8%A7%A3%E8%AF%BB/"/>
    <id>https://qmkcamel.github.io/2016/09/10/iOS中的深复制和浅复制解读/</id>
    <published>2016-09-09T16:00:00.000Z</published>
    <updated>2017-03-14T07:20:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><strong>浅复制</strong> : 并不拷贝对象，只是拷贝指向对象的指针。简单来说就是<code>指针拷贝</code>。</li>
<li><strong>深复制</strong> : 直接拷贝整个对象内存到另一块内存中。简单来说就是<code>内容拷贝</code>。</li>
</ul>
<h2 id="非集合对象"><a href="#非集合对象" class="headerlink" title="非集合对象"></a>非集合对象</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)nonCollectionObjectCopy &#123;</div><div class="line">    <span class="built_in">NSString</span> *string = <span class="string">@"string"</span>;</div><div class="line">    <span class="built_in">NSMutableString</span> *mutableString = [[<span class="built_in">NSMutableString</span> alloc] initWithString:<span class="string">@"mutableString"</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *stringCopy = [string <span class="keyword">copy</span>];</div><div class="line">    <span class="built_in">NSMutableString</span> *stringMutableCopy = [string mutableCopy];</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *mutableStringCopy = [mutableString <span class="keyword">copy</span>];</div><div class="line">    <span class="built_in">NSMutableString</span> *mutableStringMutableCopy = [mutableString mutableCopy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span>    (lldb) p string</div><div class="line"><span class="regexp">//</span>    (__NSCFConstantString *) <span class="variable">$1</span> = <span class="number">0</span>x000000010aeeade0 @<span class="string">"string"</span></div><div class="line"><span class="regexp">//</span>    (lldb) p mutableString</div><div class="line"><span class="regexp">//</span>    (__NSCFString *) <span class="variable">$2</span> = <span class="number">0</span>x0000608000266380 @<span class="string">"mutableString"</span></div><div class="line"><span class="regexp">//</span>    (lldb) p stringCopy</div><div class="line"><span class="regexp">//</span>    (__NSCFConstantString *) <span class="variable">$3</span> = <span class="number">0</span>x000000010aeeade0 @<span class="string">"string"</span></div><div class="line"><span class="regexp">//</span>    (lldb) p stringMutableCopy</div><div class="line"><span class="regexp">//</span>    (__NSCFString *) <span class="variable">$4</span> = <span class="number">0</span>x00006080002673c0 @<span class="string">"string"</span></div><div class="line"><span class="regexp">//</span>    (lldb) p mutableStringCopy</div><div class="line"><span class="regexp">//</span>    (__NSCFString *) <span class="variable">$5</span> = <span class="number">0</span>x000060800023c8a0 @<span class="string">"mutableString"</span></div><div class="line"><span class="regexp">//</span>    (lldb) p mutableStringMutableCopy</div><div class="line"><span class="regexp">//</span>    (__NSCFString *) <span class="variable">$6</span> = <span class="number">0</span>x0000608000266300 @<span class="string">"mutableString"</span></div></pre></td></tr></table></figure>
<p>结论如下：</p>
<ul>
<li><code>[immutableObject copy]</code> // 浅复制</li>
<li><code>[immutableObject mutableCopy]</code> //深复制</li>
<li><code>[mutableObject copy]</code> //深复制</li>
<li><code>[mutableObject mutableCopy]</code> //深复制</li>
</ul>
<p>PS ：<br><code>__NSCFConstantString</code>和 <code>__NSCFString</code>都是掩藏在NSString下的类。如果我们直接用语法糖来生成NSString的话，编译器会做一些优化，让静态字符都保存在一个段内。这是大部分编译器都会做的事情。</p>
<h2 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)collectionObjectCopy &#123;</div><div class="line">    <span class="built_in">NSArray</span> *array = @[<span class="string">@"A"</span>,<span class="string">@"B"</span>];</div><div class="line">    <span class="built_in">NSMutableArray</span> *mutableArray = [[<span class="built_in">NSMutableArray</span> alloc] initWithArray:@[<span class="string">@"A"</span>,<span class="string">@"B"</span>]];</div><div class="line">    </div><div class="line">    <span class="built_in">NSArray</span> *arrayCopy = [array <span class="keyword">copy</span>];</div><div class="line">    <span class="built_in">NSArray</span> *arrayMutableCopy = [array mutableCopy];</div><div class="line">    </div><div class="line">    <span class="built_in">NSArray</span> *mutableArrayCopy = [mutableArray <span class="keyword">copy</span>];</div><div class="line">    <span class="built_in">NSArray</span> *mutableArrayMutableCopy = [mutableArray mutableCopy]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span>    (lldb) p array</div><div class="line"><span class="regexp">//</span>    (__NSArrayI *) <span class="variable">$7</span> = <span class="number">0</span>x000060800023c340 @<span class="string">"2 elements"</span></div><div class="line"><span class="regexp">//</span>    (lldb) p mutableArray</div><div class="line"><span class="regexp">//</span>    (__NSArrayM *) <span class="variable">$8</span> = <span class="number">0</span>x000060800005d460 @<span class="string">"2 elements"</span></div><div class="line"><span class="regexp">//</span>    (lldb) p arrayCopy</div><div class="line"><span class="regexp">//</span>    (__NSArrayI *) <span class="variable">$9</span> = <span class="number">0</span>x000060800023c340 @<span class="string">"2 elements"</span></div><div class="line"><span class="regexp">//</span>    (lldb) p arrayMutableCopy</div><div class="line"><span class="regexp">//</span>    (__NSArrayM *) <span class="variable">$10</span> = <span class="number">0</span>x000060800005fce0 @<span class="string">"2 elements"</span></div><div class="line"><span class="regexp">//</span>    (lldb) p mutableArrayCopy</div><div class="line"><span class="regexp">//</span>    (__NSArrayI *) <span class="variable">$11</span> = <span class="number">0</span>x000060800023c120 @<span class="string">"2 elements"</span></div><div class="line"><span class="regexp">//</span>    (lldb) p mutableArrayMutableCopy</div><div class="line"><span class="regexp">//</span>    (__NSArrayM *) <span class="variable">$12</span> = <span class="number">0</span>x000060800005da30 @<span class="string">"2 elements"</span></div><div class="line"></div><div class="line"><span class="regexp">//</span> 集合中的内容还是指针拷贝</div><div class="line">(lldb) p array[<span class="number">0</span>]</div><div class="line">(__NSCFConstantString *) <span class="variable">$17</span> = <span class="number">0</span>x000000010aeeafa0 @<span class="string">"A"</span></div><div class="line">(lldb) p array[<span class="number">1</span>]</div><div class="line">(__NSCFConstantString *) <span class="variable">$18</span> = <span class="number">0</span>x000000010aeeafc0 @<span class="string">"B"</span></div><div class="line">(lldb) p arrayMutableCopy[<span class="number">0</span>]</div><div class="line">(__NSCFConstantString *) <span class="variable">$19</span> = <span class="number">0</span>x000000010aeeafa0 @<span class="string">"A"</span></div><div class="line">(lldb) p arrayMutableCopy[<span class="number">1</span>]</div><div class="line">(__NSCFConstantString *) <span class="variable">$20</span> = <span class="number">0</span>x000000010aeeafc0 @<span class="string">"B"</span></div><div class="line">(lldb)</div></pre></td></tr></table></figure>
<p>结论如下：</p>
<ul>
<li><code>[immutableObject copy]</code> // 浅复制</li>
<li><code>[immutableObject mutableCopy]</code> //单层深复制</li>
<li><code>[mutableObject copy]</code> //单层深复制</li>
<li><code>[mutableObject mutableCopy]</code> //单层深复制</li>
</ul>
<h2 id="集合对象的完全深复制"><a href="#集合对象的完全深复制" class="headerlink" title="集合对象的完全深复制"></a>集合对象的完全深复制</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)collectionObjectCompletelyCopy &#123;</div><div class="line">    <span class="built_in">NSArray</span> *array = @[<span class="string">@"A"</span>,<span class="string">@"B"</span>];</div><div class="line">    <span class="built_in">NSMutableArray</span> *arrayCompletelyCopy = [[<span class="built_in">NSMutableArray</span> alloc] initWithArray:array copyItems:<span class="literal">YES</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">NSDictionary</span> *dic = @&#123;<span class="string">@"key"</span>:<span class="string">@"value"</span>&#125;;</div><div class="line">    <span class="built_in">NSMutableDictionary</span> *dicCompeletelyMutableCopy = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithDictionary:dic copyItems:<span class="literal">YES</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的话，collection对象的内容也是深复制</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#13-用property声明的nsstring或nsarraynsdictionary经常使用copy关键字为什么如果改用strong关键字可能造成什么问题" target="_blank" rel="external">招聘一个靠谱的iOS</a></li>
<li><a href="https://www.zybuluo.com/MicroCai/note/50592" target="_blank" rel="external">iOS集合的深复制和浅复制</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;浅复制&lt;/strong&gt; : 并不拷贝对象，只是拷贝指向对象的指针。简单来说就是&lt;code&gt;指针拷贝&lt;/code
    
    </summary>
    
    
      <category term="iOS" scheme="https://qmkcamel.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS中属性的解读</title>
    <link href="https://qmkcamel.github.io/2016/08/22/iOS%E4%B8%AD%E5%B1%9E%E6%80%A7%E7%9A%84%E8%A7%A3%E8%AF%BB/"/>
    <id>https://qmkcamel.github.io/2016/08/22/iOS中属性的解读/</id>
    <published>2016-08-21T16:00:00.000Z</published>
    <updated>2017-03-13T15:04:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要有属性？"><a href="#为什么要有属性？" class="headerlink" title="为什么要有属性？"></a>为什么要有属性？</h2><p>属性是由实例变量来实现的，但却提供了一个简洁的抽象机制。编译器一般会自动生成一套存取方法，用来访问给定类型中具体给定名称的变量。<br>简单的理解就是，属性是方便生成，操作实例变量的一个手段。property = ivar + getter + setter。</p>
<p>属性分为四大类 :</p>
<ul>
<li>原子性（atomic,nonatomic）</li>
<li>读写权限（readwrite,readonly）</li>
<li>内存管理语义（assign,strong,weak,unsafe_unretained,copy）</li>
<li>方法名（getter=name,setter=name）</li>
</ul>
<p>下面分别介绍其中值得注意的地方</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p><code>atomic</code>:原子的，会通过同步锁来保证其原子性，默认值，用原子性比较影响性能，所以一般我们都会用nonatomic。</p>
<h2 id="读写权限"><a href="#读写权限" class="headerlink" title="读写权限"></a>读写权限</h2><p><code>readwrite</code>:默认值。一般都不写，编译器会自动生成所修饰属性的getter和setter。<br><code>readonly</code>:编译器一般会只生成getter。如果我们希望一个属性对外只读，对内可读写，可以在.m的class-continuation分类（是一个匿名分类）中重写为readwrite。</p>
<h2 id="内存管理语义"><a href="#内存管理语义" class="headerlink" title="内存管理语义"></a>内存管理语义</h2><p>编译器在生成setter方法的时候，要根据这个语义生成不同的代码。不影响getter方法。<br><code>assign</code>: 设置方法只会执行针对“纯量类型”的简单复制操作，一般都来修饰非对象的类型。在MRC中也用来修饰对象，与现在ARC中的unsafe_unretained语义一样。<br><code>strong</code>: 拥有关系，setter的时候会先保留新值，释放旧值，然后再将新值设置上去。<br><code>weak</code>: 非拥有关系，setter的时候既不保留新值，也不释放旧值，在属性所指的对象遭到销毁的时候，属性值也会清空，变为nil。<br><code>unsafe_unretained</code>: 语义同assign差不多，但是适用于修饰对象类型。非拥有关系（unretained不保留），当所执行的对象遭到销毁的时候，属性值不会自动清空（unsafe）。<br><code>copy</code>: setter不保留新值，而是将其拷贝（copy）。一般NSString，NSArray和NSDictionary用copy比较多。这里来举例说下<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *strongString;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>  ) <span class="built_in">NSString</span> *copiedString;</div><div class="line"></div><div class="line"><span class="comment">//用copy来保证其封装性</span></div><div class="line"><span class="built_in">NSMutableString</span> *mutableString = [[<span class="built_in">NSMutableString</span> alloc] initWithString:<span class="string">@"hello world"</span>];</div><div class="line"><span class="keyword">self</span>.strongString = mutableString;</div><div class="line"><span class="keyword">self</span>.copiedString = mutableString;</div><div class="line"></div><div class="line">(lldb) p mutableString</div><div class="line">(__NSCFString *) $<span class="number">1</span> = <span class="number">0x000060000007c680</span> <span class="string">@"hello world"</span></div><div class="line">(lldb) p <span class="keyword">self</span>.strongString</div><div class="line">(__NSCFString *) $<span class="number">2</span> = <span class="number">0x000060000007c680</span> <span class="string">@"hello world"</span></div><div class="line">(lldb) p <span class="keyword">self</span>.copiedString</div><div class="line">(__NSCFString *) $<span class="number">3</span> = <span class="number">0x000060000003a920</span> <span class="string">@"hello world"</span></div><div class="line">(lldb) p [<span class="keyword">self</span>.strongString isMemberOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]</div><div class="line">(<span class="built_in">BOOL</span>) $<span class="number">4</span> = <span class="literal">NO</span></div><div class="line">(lldb) p [<span class="keyword">self</span>.copiedString isMemberOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]</div><div class="line">(<span class="built_in">BOOL</span>) $<span class="number">5</span> = <span class="literal">NO</span></div><div class="line">(lldb) p [<span class="keyword">self</span>.strongString isKindOfClass:[objc_getClass(<span class="string">"__NSCFString"</span>) <span class="keyword">class</span>]]</div><div class="line">(<span class="built_in">BOOL</span>) $<span class="number">8</span> = <span class="literal">YES</span></div><div class="line">(lldb) p <span class="string">@"hello"</span></div><div class="line">(<span class="built_in">NSTaggedPointerString</span> *) $<span class="number">6</span> = <span class="number">0xa00006f6c6c65685</span> <span class="string">@"hello"</span></div><div class="line"><span class="comment">//stongString的地址和mutableString的地址一样，copiedString地址是新的。</span></div><div class="line"><span class="comment">//有一点值得注意是__NSCFString，很明显NSString下面另有黑幕。随后会详细介绍。</span></div></pre></td></tr></table></figure></p>
<h2 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h2><p><code>getter=&lt;name&gt;</code>: 指定“获取方法”的方法名。常用如下<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isOn) <span class="built_in">BOOL</span> on;</div></pre></td></tr></table></figure></p>
<p><code>setter=&lt;name&gt;</code>: 指定“设置方法”的方法名。一般不怎么用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要有属性？&quot;&gt;&lt;a href=&quot;#为什么要有属性？&quot; class=&quot;headerlink&quot; title=&quot;为什么要有属性？&quot;&gt;&lt;/a&gt;为什么要有属性？&lt;/h2&gt;&lt;p&gt;属性是由实例变量来实现的，但却提供了一个简洁的抽象机制。编译器一般会自动生成一套存取方法，用
    
    </summary>
    
    
      <category term="iOS" scheme="https://qmkcamel.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>软件设计的规则</title>
    <link href="https://qmkcamel.github.io/2016/08/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%88%99/"/>
    <id>https://qmkcamel.github.io/2016/08/01/软件设计的原则/</id>
    <published>2016-07-31T16:00:00.000Z</published>
    <updated>2017-03-10T16:12:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ol>
<li>软件的目的是帮助别人。</li>
<li>相比降低开发成本，更重要的是降低维护的成本。</li>
<li>变化定律：程序存在的时间越长，他的某个部分需要变化的可能性越大。</li>
<li>缺陷定律：程序出现缺陷的可能性，正比于你对他所做修改的程度。</li>
<li>简洁定律：软件任何一部分的维护难度，正比于该部分的简洁程度。</li>
<li>测试定律：你对软件行为的了解程度，等与你真正测试他的程度。<br>from <a href="https://book.douban.com/subject/20445258/" target="_blank" rel="external">简约之美</a></li>
</ol>
</blockquote>
<p>在发开经过一段时间之后，随着维护成本的不断提高，越来越感到下面两点的重要性。</p>
<ul>
<li>相比降低开发成本，降低维护成本更加重要。</li>
<li>维护成本正比于系统的复杂程度。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;软件的目的是帮助别人。&lt;/li&gt;
&lt;li&gt;相比降低开发成本，更重要的是降低维护的成本。&lt;/li&gt;
&lt;li&gt;变化定律：程序存在的时间越长，他的某个部分需要变化的可能性越大。&lt;/li&gt;
&lt;li&gt;缺陷定律：程序出现缺陷的可能性，正比于你对他所
    
    </summary>
    
    
      <category term="软件工程" scheme="https://qmkcamel.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="瞎扯" scheme="https://qmkcamel.github.io/tags/%E7%9E%8E%E6%89%AF/"/>
    
  </entry>
  
  <entry>
    <title>Joel Test</title>
    <link href="https://qmkcamel.github.io/2016/07/28/Joel%20Test/"/>
    <id>https://qmkcamel.github.io/2016/07/28/Joel Test/</id>
    <published>2016-07-27T16:00:00.000Z</published>
    <updated>2017-03-07T10:15:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>你们使用源代码控制吗？</li>
<li>你们每步都做构建吗？</li>
<li>你们每日都做构建吗？</li>
<li>你们有缺陷数据库吗？</li>
<li>你们会在写新代码之前修复缺陷吗？</li>
<li>你们有与当前工作吻合的进度安排吗？</li>
<li>你们有规约吗？</li>
<li>程序员工作环境安静吗？</li>
<li>你们采用了市面上最好的工具吗？</li>
<li>你们有测试人员吗？</li>
<li>你们会要求应聘者在面试时写代码吗？</li>
<li>你们做走廊可用性测试吗？</li>
</ul>
</blockquote>
<p>很早之前提出来的12个问题，现在看起来貌似很普通，但是能都做到的话还是很厉害的。</p>
<p>走廊性测试让我想到了一个问题，如果某些功能连开发者自己都一脸茫然的话，用户肯定更是丈二和尚摸不着头了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;你们使用源代码控制吗？&lt;/li&gt;
&lt;li&gt;你们每步都做构建吗？&lt;/li&gt;
&lt;li&gt;你们每日都做构建吗？&lt;/li&gt;
&lt;li&gt;你们有缺陷数据库吗？&lt;/li&gt;
&lt;li&gt;你们会在写新代码之前修复缺陷吗？&lt;/li&gt;
&lt;li&gt;你们有与当前工作吻合的
    
    </summary>
    
    
      <category term="软件工程" scheme="https://qmkcamel.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="瞎扯" scheme="https://qmkcamel.github.io/tags/%E7%9E%8E%E6%89%AF/"/>
    
  </entry>
  
  <entry>
    <title>App执行状态</title>
    <link href="https://qmkcamel.github.io/2016/07/15/App%E6%89%A7%E8%A1%8C%E7%8A%B6%E6%80%81/"/>
    <id>https://qmkcamel.github.io/2016/07/15/App执行状态/</id>
    <published>2016-07-14T16:00:00.000Z</published>
    <updated>2017-03-07T09:58:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iOS执行状态"><a href="#iOS执行状态" class="headerlink" title="iOS执行状态"></a>iOS执行状态</h2><ul>
<li>Not running<ul>
<li>The app has not been launched or was running but was terminated by the system.</li>
</ul>
</li>
<li>Inactive<ul>
<li>The app is running in the foreground but is currently not receiving events. (It may be executing other code though.) An app usually stays in this state only briefly as it transitions to a different state.</li>
</ul>
</li>
<li>Active<ul>
<li>The app is running in the foreground and is receiving events. This is the normal mode for foreground apps.</li>
</ul>
</li>
<li>Background<ul>
<li>The app is in the background and executing code. Most apps enter this state briefly on their way to being suspended. However, an app that requests extra execution time may remain in this state for a period of time. In addition, an app being launched directly into the background enters this state instead of the inactive state. For information about how to execute code while in the background, see Background Execution.</li>
</ul>
</li>
<li>Suspended<ul>
<li>The app is in the background but is not executing code. The system moves apps to this state automatically and does not notify them before doing so. While suspended, an app remains in memory but does not execute any code.<br>When a low-memory condition occurs, the system may purge suspended apps without notice to make more space for the foreground app.</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;iOS执行状态&quot;&gt;&lt;a href=&quot;#iOS执行状态&quot; class=&quot;headerlink&quot; title=&quot;iOS执行状态&quot;&gt;&lt;/a&gt;iOS执行状态&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Not running&lt;ul&gt;
&lt;li&gt;The app has not been lau
    
    </summary>
    
    
      <category term="App" scheme="https://qmkcamel.github.io/tags/App/"/>
    
      <category term="iOS" scheme="https://qmkcamel.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Designated和Secondary(Convenience)初始化方法</title>
    <link href="https://qmkcamel.github.io/2016/07/09/Designated%E5%92%8CSecondary(Convenience)%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <id>https://qmkcamel.github.io/2016/07/09/Designated和Secondary(Convenience)初始化方法/</id>
    <published>2016-07-08T16:00:00.000Z</published>
    <updated>2017-03-09T05:59:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两步创建"><a href="#两步创建" class="headerlink" title="两步创建"></a>两步创建</h2><p>如下所以，分配内存和初始化对象被分为两步来进行<br><code>[[NSObject alloc] init]</code></p>
<ul>
<li>alloc 创建对象，分配足够的内存，写入isa指针，初始化引用计数，重置所以实例变量</li>
<li>init 初始化对象，使对象处于可用的状态。为对象的实例变量赋予合理有用的值</li>
</ul>
<h2 id="designated"><a href="#designated" class="headerlink" title="designated"></a>designated</h2><ul>
<li>只有一个</li>
<li>提供所有的参数 </li>
</ul>
<h3 id="定义一个新类的时候如何做"><a href="#定义一个新类的时候如何做" class="headerlink" title="定义一个新类的时候如何做"></a>定义一个新类的时候如何做</h3><ul>
<li>不需要重载任何初始化函数</li>
<li>重载designated initializer</li>
<li>重新定义一个designated initializer</li>
</ul>
<h3 id="需要提供自己的初始化函数时需要怎么做"><a href="#需要提供自己的初始化函数时需要怎么做" class="headerlink" title="需要提供自己的初始化函数时需要怎么做"></a>需要提供自己的初始化函数时需要怎么做</h3><ul>
<li>定义自己的designated initializer，确保调用了直接超类的designated initializer</li>
<li>重载直接超类的designated initializer，调用你的新designated initializer</li>
<li>为新的designated initializer写文档</li>
</ul>
<h2 id="secondary"><a href="#secondary" class="headerlink" title="secondary"></a>secondary</h2><ul>
<li>一个或者多个</li>
<li>提供一个或者多个默认参数</li>
<li>需要调用designated方法</li>
</ul>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span> 的 designated initializer 有两个，分别是</div><div class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div><div class="line"></div><div class="line">我们有一个类就叫 <span class="built_in">MKSubView</span> : <span class="built_in">UIView</span> </div><div class="line">然后我们在.m 中如果这样来些初始化类的话,.h没有任何说明的话，就会有一些问题，没有重载直接超类的designated initializer </div><div class="line">- （instance）init &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">        <span class="comment">//something to do</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="number">1.</span> [[<span class="built_in">MKSubView</span> alloc] initWithFrame:frame]</div><div class="line"><span class="number">2.</span> [<span class="built_in">MKSubView</span> new]</div><div class="line"><span class="number">3.</span> [[<span class="built_in">MKSubView</span> alloc] init]</div><div class="line">如果我们用 <span class="number">1</span> 来初始化的话，不会被正确的初始化。</div><div class="line">只有这样 <span class="number">2</span> 或者 <span class="number">3</span> 才会正确执行初始化。</div><div class="line">但是不能保证所以人都认真看了代码，尤其是你做一个这样的类给别人用的时候。</div><div class="line"></div><div class="line">正确方法是直接重载直接父类的designated initializer</div><div class="line"> </div><div class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]) &#123;</div><div class="line">        <span class="comment">//something to do </span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">这样的话调用 <span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span> 就都能保证正常初始化了</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/oa414/objc-zen-book-cn#%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B" target="_blank" rel="external">https://github.com/oa414/objc-zen-book-cn#%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;两步创建&quot;&gt;&lt;a href=&quot;#两步创建&quot; class=&quot;headerlink&quot; title=&quot;两步创建&quot;&gt;&lt;/a&gt;两步创建&lt;/h2&gt;&lt;p&gt;如下所以，分配内存和初始化对象被分为两步来进行&lt;br&gt;&lt;code&gt;[[NSObject alloc] init]&lt;/code
    
    </summary>
    
    
      <category term="iOS" scheme="https://qmkcamel.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>网络协议概览</title>
    <link href="https://qmkcamel.github.io/2016/07/09/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%A7%88/"/>
    <id>https://qmkcamel.github.io/2016/07/09/网络协议概览/</id>
    <published>2016-07-08T16:00:00.000Z</published>
    <updated>2017-03-07T09:58:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="0-1"><a href="#0-1" class="headerlink" title="0,1"></a>0,1</h3><h2 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h2><h3 id="Ethernet（以太网）"><a href="#Ethernet（以太网）" class="headerlink" title="Ethernet（以太网）"></a>Ethernet（以太网）</h3><h3 id="Wifi"><a href="#Wifi" class="headerlink" title="Wifi"></a>Wifi</h3><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="ICMP（介于网络层和传输层）"><a href="#ICMP（介于网络层和传输层）" class="headerlink" title="ICMP（介于网络层和传输层）"></a>ICMP（介于网络层和传输层）</h3><p>Internet Control Message Protocol</p>
<ul>
<li><p>回音(echo)<br>ping 命令</p>
</li>
<li><p>源头冷却(source quench)</p>
</li>
<li><p>目的地无法到达(destination unreachable)</p>
</li>
<li><p>超时(tiem exceeded)<br>traceroute 用这种类型</p>
</li>
<li><p>重新定向(redirect)</p>
</li>
</ul>
<h3 id="IPv4-IPv6"><a href="#IPv4-IPv6" class="headerlink" title="IPv4/IPv6"></a>IPv4/IPv6</h3><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul>
<li><p>滑动窗口</p>
<ul>
<li><p>累计ACK(而且会故意有一定的延迟)</p>
</li>
<li><p>流量控制</p>
</li>
<li><p>零窗口</p>
</li>
<li><p>白痴窗口综合症</p>
</li>
</ul>
</li>
<li><p>三次握手/四次挥手</p>
</li>
<li><p>重发</p>
<ul>
<li><p>超时重新发送</p>
</li>
<li><p>快速重新发送</p>
</li>
</ul>
</li>
<li><p>堵塞控制</p>
<ul>
<li><p>阻塞窗口</p>
<ul>
<li><p>慢启动</p>
</li>
<li><p>阻塞避免</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul>
<li>感觉像是实现了端口的IP</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>基于UDP<br>Linux 查看DNS 服务地址 cat /etc/resolv.conf</p>
<ul>
<li><p>DNS劫持</p>
</li>
<li><p>DNS缓存</p>
</li>
<li><p>DNS查询</p>
</li>
<li><p>反向DNS</p>
</li>
</ul>
<h3 id="HTTP-HTTPS"><a href="#HTTP-HTTPS" class="headerlink" title="HTTP/HTTPS"></a>HTTP/HTTPS</h3><p>大多基与TCP 偶尔基于UDP  </p>
<p>以前HTTP连接完成之后就会断开底层的TCP,每次重新建立连接都需要耗费时间。现在如果IP和端口一样的，会使用同一个TCP连接，但是HTTP仍是无状态的。</p>
<ul>
<li><p>格式</p>
<ul>
<li><p>起始行</p>
<ul>
<li><p>request</p>
<ul>
<li><p>资源路径</p>
</li>
<li><p>协议</p>
</li>
<li><p>Host</p>
</li>
</ul>
</li>
<li><p>response</p>
<ul>
<li><p>协议</p>
</li>
<li><p>状态码</p>
</li>
<li><p>状态码描述</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>头信息</p>
</li>
<li><p>主体</p>
</li>
</ul>
</li>
<li><p>默认80端口</p>
</li>
<li><p>发展历程</p>
<ul>
<li><p>0.9</p>
<ul>
<li><p>只有一个get</p>
</li>
<li><p>只能返回HTML格式的字符串</p>
</li>
</ul>
</li>
<li><p>1.0</p>
<ul>
<li><p>返回格式任意</p>
</li>
<li><p>引入POST/HEAD</p>
</li>
<li><p>增加了 HTTP Header</p>
</li>
<li><p>其他新增：状态码，多字符集支持，多部分发送，权限，缓存，内容编码</p>
</li>
<li><p>缺点<br>主要缺点:每个TCP连接只能发送一个请求，发送数据完毕，就关闭连接。三次握手成本高。<br>为了解决这个问题：部分浏览器在请求的header 里面用了非标准的Connection: keep-alive 告诉不要断开连接，服务器也返回同样，然后就可以复用了。</p>
</li>
</ul>
</li>
<li><p>1.1</p>
<ul>
<li><p>持久连接</p>
<ul>
<li><p>TCP连接默认不关闭</p>
</li>
<li><p>发现没活动可以主动关闭连接（规范做法：客户端最后一个请求发送 Connection:Close）</p>
</li>
<li><p>同一个域名，大多浏览器最大同时建立6个持久连接</p>
</li>
</ul>
</li>
<li><p>管道机制</p>
<ul>
<li><p>同一个TCP,客户端同时发送多个请求</p>
</li>
<li><p>以前：同一个TCP，发送A，收到回复，然后发B</p>
</li>
<li><p>现在：同一个TCP,可以同时发送A,B，但是服务器还是按照顺序来</p>
</li>
</ul>
</li>
<li><p>Content-Length字段</p>
<ul>
<li>区分数据包是属于哪一个回应的</li>
</ul>
</li>
<li><p>分块传输编码</p>
<ul>
<li>采用流模式取代缓存模式，Transfer-Encoding,表明回应有数量未定的数据块组成</li>
</ul>
</li>
<li><p>增加了的动词: PUT PATCH HEAD OPTION DELETE</p>
</li>
<li><p>缺点<br>允许TCP复用，同一个TCP里，所有数据还是按次序来的。可能会造成队头堵塞。<br>避免这个问题：1.减少请求次数 2.同时多开持久连接。<br>产生了很多网页优化技巧：  </p>
<ol>
<li>合并脚本和样式表 2. 图片嵌入CSS 3. 域名分片</li>
</ol>
</li>
</ul>
</li>
<li><p>2.0</p>
<ul>
<li><p>SPDY(2.0的前身)</p>
</li>
<li><p>二进制协议</p>
</li>
<li><p>多工</p>
</li>
<li><p>数据流</p>
</li>
<li><p>头信息压缩</p>
</li>
<li><p>服务器推送</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTPS证书分类<br><a href="http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html</a></p>
<ul>
<li><p>认证级别</p>
<ul>
<li><p>域名认证<br>可以确认申请人拥有这个域名</p>
</li>
<li><p>公司认证<br>确认域名是哪一家公司，证书里有公司信息</p>
</li>
<li><p>扩展认证<br>最高级别认证，浏览器会显示公司名<br>比如payple</p>
</li>
</ul>
</li>
<li><p>覆盖范围</p>
<ul>
<li><p>单域名认证</p>
</li>
<li><p>通配符证书<br>可以用于某个域名和其一级子域名，比如<a href="http://foo.com" target="_blank" rel="external">foo.com</a>和*.<a href="http://foo.com" target="_blank" rel="external">foo.com</a></p>
</li>
<li><p>多域名证书</p>
</li>
</ul>
</li>
<li><p>免费证书<br>电子前哨基金会EFF 成立了<br><a href="https://letsencrypt.org/" target="_blank" rel="external">https://letsencrypt.org/</a></p>
</li>
</ul>
</li>
</ul>
<h3 id="DHCP（Danamic-Host-Configuration-Protocol）"><a href="#DHCP（Danamic-Host-Configuration-Protocol）" class="headerlink" title="DHCP（Danamic Host Configuration Protocol）"></a>DHCP（Danamic Host Configuration Protocol）</h3><ul>
<li><p>四步通信</p>
<ul>
<li><p>Discovery：客户端发广播，寻找DHCP服务器</p>
</li>
<li><p>Offer：DHCP服务器发出邀请，提供一个可用的IP地址</p>
</li>
<li><p>Request：客户端正式请求使用该IP地址</p>
</li>
<li><p>Acknowledge：DHCP服务器确认，并提供其他配置参数</p>
</li>
</ul>
</li>
<li><p>DHCP攻击<br>攻击者不断发送DHCP请求，冒充新入网的客户机。DHCP的地址池会耗干，新入网的用户无法分配IP地址。<br>攻击者在有了大量的IP地址之后，拌成新的DHCP服务器，提供网络设置参数，让自己成为DNS服务器或者网络出口。客户机的域名解析和外网通信就必须经过攻击者的主机了。</p>
</li>
</ul>
<h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3><ul>
<li><p>SSL(Secure Socket Layer)</p>
<ul>
<li><p>用对称加密方法加密信息本身</p>
</li>
<li><p>用非对称加密方法加密生成密钥的参数</p>
</li>
<li><p>握手(handshake)</p>
<ol>
<li>生成对话密钥一共需要三个参数  </li>
<li><p>握手之后的对话使用“对话密钥”加密（对称加密），服务器的公钥和私钥只用于加密和解密“对话密钥”（非堆成加密），无其他作用<br>3.服务器的公钥放在数字证书中</p>
<ul>
<li><p>Client给出协议版本号，随机生成数A，支持的加密方式</p>
</li>
<li><p>server确认加密方式，给出数字证书，随机生成数B</p>
</li>
<li><p>Client确认证书有效，重新生成一个随机数C，用证书的公钥加密数字，发给server</p>
</li>
<li><p>Server用私钥获取数字C</p>
</li>
<li><p>按约定的加密方法，使用前面的三个随机数生成密钥，加密后续的对话过程</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>session的恢复</p>
<ul>
<li><p>session ID<br>每次对话都有一个session ID。如果中断，下次重连的时候，只要客户端给出这个编号，服务器如果有编号记录的话，就可以重新使用已有的“对话密钥”，不用重新生成。<br>缺点：session ID 只保存在一个机器上，如果请求打到另外的机器上，就得重新握手<br>优点：所有的浏览器都支持</p>
</li>
<li><p>session ticket<br>缺点：部分浏览器支持<br>发送服务器在上一个会话中发送过来的session ticket，这个是加密的只有在服务端可以解密，包括了对话密钥和加密方法等。所有的机器上都可以解密，就不用重新生成对话密钥了。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>TLS(Transport Layer Secure)</p>
</li>
<li><p>加密方式</p>
<ul>
<li><p>对称加密</p>
<ul>
<li>保存和传递密钥很容易被破解</li>
</ul>
</li>
<li><p>非对称加密</p>
<ul>
<li><p>公钥/私钥</p>
</li>
<li><p>RSA</p>
</li>
<li><p>运算成本高</p>
</li>
<li><p>DH算法</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;物理层&quot;&gt;&lt;a href=&quot;#物理层&quot; class=&quot;headerlink&quot; title=&quot;物理层&quot;&gt;&lt;/a&gt;物理层&lt;/h2&gt;&lt;h3 id=&quot;0-1&quot;&gt;&lt;a href=&quot;#0-1&quot; class=&quot;headerlink&quot; title=&quot;0,1&quot;&gt;&lt;/a&gt;0,1&lt;/h
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://qmkcamel.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://qmkcamel.github.io/2016/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://qmkcamel.github.io/2016/07/07/线程池/</id>
    <published>2016-07-06T16:00:00.000Z</published>
    <updated>2017-03-07T09:58:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工作者线程worker"><a href="#工作者线程worker" class="headerlink" title="工作者线程worker"></a>工作者线程worker</h3><p>线程池中可以重复利用来执行任务的线程，一个worker在其生命周期中会执行多个job。</p>
<ul>
<li>复用：复用一个worker去处理多个job</li>
<li>流控：通过对worker数量控制来控制并发数量。也可以通过控制队列来实现。</li>
</ul>
<p>通过对worker数量的控制可以实现线程池容量的伸缩来实现复杂的业务需求</p>
<h3 id="待处理工作job的存储队列"><a href="#待处理工作job的存储队列" class="headerlink" title="待处理工作job的存储队列"></a>待处理工作job的存储队列</h3><p>对于来不及处理的job需要放到等待队列里。空闲的worker会从job队列中取任务来执行。<br>可以对队列做不同的处理，来实现不同功能的线程池。</p>
<p>队列类型举例：</p>
<ul>
<li>同步阻塞队列（SynchronousQueue）</li>
<li>有界队列（ArrayBlockingQueue）</li>
<li>无界队列（LinkedBlockingQueue）</li>
<li>优先级队列（PriorityBlockingQueue）</li>
</ul>
<h3 id="线程池初始化"><a href="#线程池初始化" class="headerlink" title="线程池初始化"></a>线程池初始化</h3><p>线程池参数的初始化和workers的初始化</p>
<ul>
<li>一开始初始化指定数量的workers ：线程池启动初期会比较快，但空载时会造成少量的浪费</li>
<li>逐步初始化 ：线程池启动初期性能达不到最优。</li>
</ul>
<h3 id="处理业务job算法"><a href="#处理业务job算法" class="headerlink" title="处理业务job算法"></a>处理业务job算法</h3><ul>
<li>直接处理</li>
<li>增加worker处理</li>
<li>放入等待队列</li>
</ul>
<p>JDK实现举例</p>
<ol>
<li>工作者workers数量低于核心工作者数corePoolSize时会优先创建一个工作者worker处理job，处理成功则返回。</li>
<li>工作者workers数量高于核心工作者数时会优先把job放入到待处理队列，放入队列成功时处理结束。</li>
<li>步骤2中入队失败会识别工作者数是否还小于最大工作者数maximumPoolsize，小于的话也会新创建一个工作者worker处理job。</li>
<li>拒绝处理</li>
</ol>
<h3 id="workers的增减算法"><a href="#workers的增减算法" class="headerlink" title="workers的增减算法"></a>workers的增减算法</h3><p>业务线程数不是持久不变的，有高低峰期。线程池要有自己的算法根据业务请求频率高低调节自身工作者workers的数量来调节线程池大小，从而实现业务高峰期增加工作者数量提高响应速度，而业务低峰期减少工作者数来节省服务器资源。</p>
<p>增加算法通常基于几个维度进行：</p>
<ul>
<li>待处理工作job数。</li>
<li>线程池定义的最大最小工作者数。</li>
<li>工作者闲置时间。</li>
</ul>
<p>JDK举例</p>
<ul>
<li><p>增加</p>
<ol>
<li>待处理job来时，工作者workers数量低于核心工作者数corePoolSize时。</li>
<li>待处理job来时，workers数超过核心数小于最大工作者数且入待处理队列失败场景。</li>
<li>业务调用线程池的更新核心工作者数接口时，若发现扩容，会增加工作者数。</li>
</ol>
</li>
<li><p>减少</p>
<ol>
<li>待处理任务队列里没有job并且工作者workers数量超过了核心工作者数corePoolSize。</li>
<li>待处理任务队列里没有job并且允许工作者数量小于核心工作者参数为true，此场景会至少保留一个工作者线程。</li>
</ol>
</li>
</ul>
<h3 id="线程池的终止"><a href="#线程池的终止" class="headerlink" title="线程池的终止"></a>线程池的终止</h3><p>应用停止时线程池要有自身的停止逻辑，保证所有job都得到执行或者抛弃</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.infoq.com/cn/articles/thread-pool-algorithm-realization" target="_blank" rel="external">Ref</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工作者线程worker&quot;&gt;&lt;a href=&quot;#工作者线程worker&quot; class=&quot;headerlink&quot; title=&quot;工作者线程worker&quot;&gt;&lt;/a&gt;工作者线程worker&lt;/h3&gt;&lt;p&gt;线程池中可以重复利用来执行任务的线程，一个worker在其生命周期中
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://qmkcamel.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
